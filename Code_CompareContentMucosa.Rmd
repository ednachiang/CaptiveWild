---
title: "Compare Content vs. Mucosa"
author: "Edna Chiang"
date: "3/30/2021"
output: html_document
---

### Load Libraries
```{r}
library(ape)
library(dplyr)
library(dunn.test)
library(ggplot2)
library(grid)
library(phyloseq)
library(picante)
library(phytools)
library(tidyr)
library(vegan)
library(equivalence)

theme_set(theme_bw())
set.seed(1)
```


### Import Data
```{r}
# Link files
shared = "mothur_output/final.shared"
taxonomy = "mothur_output/final.taxonomy"
tree = "mothur_output/final.tre"

# Import mothur data
mothurdata = import_mothur(
  mothur_shared_file = shared,
  mothur_constaxonomy_file = taxonomy,
  mothur_tree_file = tree)

# Add OTU column in taxonomy table
tax_table(mothurdata) <- cbind(tax_table(mothurdata), 
                               row.names(tax_table(mothurdata)))

# Rename taxonomy table columns
colnames(tax_table(mothurdata)) <- 
  c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species")

# Remove OTUs that appear in < 3 samples
otu <- data.frame(otu_table(mothurdata))
otu.rem <- list()
for(i in 1:nrow(otu)){
  empty <- length(which(otu[i,] == 0))
    # Identifies # of samples w/o OTU
  if(empty > 54){
    # If OTU appears in < 3 samples
    otu.rem <- append(otu.rem, i)
      # Create list of OTUs that appear in only 1 sample
  }
}
otu.rem.row <- as.numeric(otu.rem)
  # Convert list to numeric
otu.rem.df <- otu[-otu.rem.row,]
  # Remove OTUs
otu.rem.tab <- otu_table(otu.rem.df, taxa_are_rows = T)
  # Convert trimmed OTU table to otu_table

# Add metadata
meta <- read.csv("metadata.csv")
rownames(meta) <- meta$Sample
divsum <- read.table("mothur_output/final.summary", header = T)
meta[,12:21] <- divsum[,3:12]

# Update phyloseq object
physeq <- merge_phyloseq(otu.rem.tab, tax_table(mothurdata), sample_data(meta),
                         phy_tree(mothurdata))

# Order factors
sample_data(physeq)$Season <- ordered(sample_data(physeq)$Season,
                                     levels=c("Summer", "Winter", "Spring"))
sample_data(physeq)$Metabolism <- ordered(sample_data(physeq)$Metabolism,
                                     levels=c("Active", "Torpor", "IBA"))
sample_data(physeq)$Group <- ordered(sample_data(physeq)$Group,
                                     levels=c("Summer_Wild", "Summer_Lab", "Torpor", "IBA", "Spring"))

# Remove outliers
physeq <- subset_samples(physeq, ID != 3925)
physeq <- subset_samples(physeq, ID != 3916)

# Subset out unpaired samples
physeq.pair <- subset_samples(physeq, ID != 3881)
physeq.pair <- subset_samples(physeq.pair, ID != 3886)
physeq.pair <- subset_samples(physeq.pair, ID != 4057)

# Separate by season
physeq.wild <- subset_samples(physeq.pair, Group == "Summer_Wild")
physeq.sum <- subset_samples(physeq.pair, Group == "Summer_Lab")
physeq.tor <- subset_samples(physeq.pair, Group == "Torpor")
physeq.iba <- subset_samples(physeq.pair, Group == "IBA")
physeq.spr <- subset_samples(physeq.pair, Group == "Spring")

# Separate by content/mucosa
physeq.con <- subset_samples(physeq.pair, Sample_Type == "Content")
physeq.muc <- subset_samples(physeq.pair, Sample_Type == "Mucosa")

```




### RTOST 
```{r}
# Code modified from Skarlupka, et al. (2019)
# https://doi.org/10.1186/s40104-019-0375-0

# Format OTU table
TOST.otu <- data.frame(t(data.frame(otu_table(physeq.pair))))
TOST.otu$Sample <- rownames(TOST.otu)
TOST.otu$Sample_Type <- substr(rownames(TOST.otu), start = 2, stop = 2)


# Separate by sample type
TOST.otu.con <- TOST.otu[which(TOST.otu$Sample_Type == "C"),]
TOST.otu.muc <- TOST.otu[which(TOST.otu$Sample_Type == "M"),]

# Calculate OTU means; remove Sample and Sample Type cols I made
TOST.otu.con.mean <- aggregate(TOST.otu.con[ , 1 : ( ncol(TOST.otu.con) - 2) ],
                               list(TOST.otu.con$Sample_Type), mean)
TOST.otu.con.mean <- TOST.otu.con.mean[-1]
TOST.otu.muc.mean <- aggregate(TOST.otu.muc[ , 1 : ( ncol(TOST.otu.muc) - 2) ],
                               list(TOST.otu.muc$Sample_Type), mean)
TOST.otu.muc.mean <- TOST.otu.muc.mean[-1]


# Prepare data
TOST.otu.con.t <- t(as.matrix(sapply(TOST.otu.con.mean[,1:1618], as.numeric)))
TOST.otu.muc.t <- t(as.matrix(sapply(TOST.otu.muc.mean[,1:1618], as.numeric)))






rtost.output.df <- data.frame(matrix(NA, ncol = 3, nrow = nrow(TOST.otu.muc)))
colnames(rtost.output.df) <- c("Sample1", "Sample2", "P")

for(i in 1:nrow(TOST.otu.muc)){
  sample1 <- rownames(TOST.otu.muc)[i]
  sample1Split <- strsplit(sample1, "_")
  ID1 <- sample1Split[[1]][[2]]
  #print(i)
  #print(ID1)
  
  for(j in 1:nrow(TOST.otu.con)){
    sample2 <- rownames(TOST.otu.con)[j]
    sample2Split <- strsplit(sample2, "_")
    ID2 <- sample2Split[[1]][[2]]
    
    if(ID1 == ID2){
      #print(j)
      #print(ID2)
      muc.t <- t(as.matrix(sapply(TOST.otu.muc[i,1:(ncol(TOST.otu.muc)-2)], as.numeric)))
      con.t <- t(as.matrix(sapply(TOST.otu.con[j,1:(ncol(TOST.otu.con)-2)], as.numeric)))
      rtostOutput <- rtost(muc.t, con.t, paired = T, alpha = 0.05, epsilon = 0.25, tr = 0.15)
      print(rtostOutput)

      
      rtost.output.df$Sample1[i] = sample1
      rtost.output.df$Sample2[i] = sample2
      rtost.output.df$P[i] = rtostOutput$p.value
    }
  }
  
}

# Lots of errors saying standard deviation is zero. Will this test still work if sd = 0?

rtost.output.df$Padj <- p.adjust(rtost.output.df$P, "fdr")

#write.csv(rtost.output.df, "rtost.output.df.csv")



################ By Group ################

#Format OTU table
TOST.otu.w <- data.frame(t(data.frame(otu_table(physeq.wild))))
TOST.otu.w$Sample <- rownames(TOST.otu.w)
TOST.otu.w$Sample_Type <- substr(rownames(TOST.otu.w), start = 2, stop = 2)

# Separate by sample type
TOST.otu.w.con <- TOST.otu.w[which(TOST.otu.w$Sample_Type == "C"),]
TOST.otu.w.muc <- TOST.otu.w[which(TOST.otu.w$Sample_Type == "M"),]

# Calculate OTU means; remove Sample and Sample Type cols I made
TOST.otu.w.con.mean <- aggregate(TOST.otu.w.con[ , 1 : ( ncol(TOST.otu.w.con) - 2) ],
                               list(TOST.otu.w.con$Sample_Type), mean)
TOST.otu.w.con.mean <- TOST.otu.w.con.mean[-1]
TOST.otu.w.muc.mean <- aggregate(TOST.otu.w.muc[ , 1 : ( ncol(TOST.otu.w.muc) - 2) ],
                               list(TOST.otu.w.muc$Sample_Type), mean)
TOST.otu.w.muc.mean <- TOST.otu.w.muc.mean[-1]


# Prepare data
TOST.otu.w.con.t <- t(as.matrix(sapply(TOST.otu.w.con.mean[,1:(ncol(TOST.otu.w.con)-2)], as.numeric)))
TOST.otu.w.muc.t <- t(as.matrix(sapply(TOST.otu.w.muc.mean[,1:(ncol(TOST.otu.w.muc)-2)], as.numeric)))

rtost.w.output.df <- data.frame(matrix(NA, ncol = 3, nrow = nrow(TOST.otu.w.muc)))
colnames(rtost.w.output.df) <- c("Sample1", "Sample2", "P")


for(i in 1:nrow(TOST.otu.w.muc)){
  sample1 <- rownames(TOST.otu.w.muc)[i]
  sample1Split <- strsplit(sample1, "_")
  ID1 <- sample1Split[[1]][[2]]
  
  muc.t <- t(as.matrix(sapply(TOST.otu.muc[i,1:(ncol(TOST.otu.muc)-2)], as.numeric)))
  rtostOutput <- rtost(muc.t, TOST.otu.w.con.t, paired = F, epsilon = 0.25, tr = 0.15)
      
  rtost.w.output.df$Sample1[i] = sample1
  rtost.w.output.df$Sample2[i] = "Wild Content"
  rtost.w.output.df$P[i] = rtostOutput$p.value
}

rtost.w.output.df$Padj <- p.adjust(rtost.w.output.df$P, "fdr")


#Format OTU table
TOST.otu.s <- data.frame(t(data.frame(otu_table(physeq.sum))))
TOST.otu.s$Sample <- rownames(TOST.otu.s)
TOST.otu.s$Sample_Type <- substr(rownames(TOST.otu.s), start = 2, stop = 2)

# Separate by sample type
TOST.otu.s.con <- TOST.otu.s[which(TOST.otu.s$Sample_Type == "C"),]
TOST.otu.s.muc <- TOST.otu.s[which(TOST.otu.s$Sample_Type == "M"),]

# Calculate OTU means; remove Sample and Sample Type cols I made
TOST.otu.s.con.mean <- aggregate(TOST.otu.s.con[ , 1 : ( ncol(TOST.otu.s.con) - 2) ],
                               list(TOST.otu.s.con$Sample_Type), mean)
TOST.otu.s.con.mean <- TOST.otu.s.con.mean[-1]
TOST.otu.s.muc.mean <- aggregate(TOST.otu.s.muc[ , 1 : ( ncol(TOST.otu.s.muc) - 2) ],
                               list(TOST.otu.s.muc$Sample_Type), mean)
TOST.otu.s.muc.mean <- TOST.otu.s.muc.mean[-1]


# Prepare data
TOST.otu.s.con.t <- t(as.matrix(sapply(TOST.otu.s.con.mean[,1:(ncol(TOST.otu.s.con)-2)], as.numeric)))
TOST.otu.s.muc.t <- t(as.matrix(sapply(TOST.otu.s.muc.mean[,1:(ncol(TOST.otu.s.muc)-2)], as.numeric)))

rtost.s.output.df <- data.frame(matrix(NA, ncol = 3, nrow = nrow(TOST.otu.s.muc)))
colnames(rtost.s.output.df) <- c("Sample1", "Sample2", "P")


for(i in 1:nrow(TOST.otu.s.muc)){
  sample1 <- rownames(TOST.otu.s.muc)[i]
  sample1Split <- strsplit(sample1, "_")
  ID1 <- sample1Split[[1]][[2]]
  
  muc.t <- t(as.matrix(sapply(TOST.otu.muc[i,1:(ncol(TOST.otu.muc)-2)], as.numeric)))
  rtostOutput <- rtost(muc.t, TOST.otu.s.con.t, paired = F, epsilon = 0.25, tr = 0.15)
      
  rtost.s.output.df$Sample1[i] = sample1
  rtost.s.output.df$Sample2[i] = "Summer Content"
  rtost.s.output.df$P[i] = rtostOutput$p.value
}

rtost.s.output.df$Padj <- p.adjust(rtost.s.output.df$P, "fdr")



#Format OTU table
TOST.otu.t <- data.frame(t(data.frame(otu_table(physeq.tor))))
TOST.otu.t$Sample <- rownames(TOST.otu.t)
TOST.otu.t$Sample_Type <- substr(rownames(TOST.otu.t), start = 2, stop = 2)

# Separate by sample type
TOST.otu.t.con <- TOST.otu.t[which(TOST.otu.t$Sample_Type == "C"),]
TOST.otu.t.muc <- TOST.otu.t[which(TOST.otu.t$Sample_Type == "M"),]

# Calculate OTU means; remove Sample and Sample Type cols I made
TOST.otu.t.con.mean <- aggregate(TOST.otu.t.con[ , 1 : ( ncol(TOST.otu.t.con) - 2) ],
                               list(TOST.otu.t.con$Sample_Type), mean)
TOST.otu.t.con.mean <- TOST.otu.t.con.mean[-1]
TOST.otu.t.muc.mean <- aggregate(TOST.otu.t.muc[ , 1 : ( ncol(TOST.otu.t.muc) - 2) ],
                               list(TOST.otu.t.muc$Sample_Type), mean)
TOST.otu.t.muc.mean <- TOST.otu.t.muc.mean[-1]


# Prepare data
TOST.otu.t.con.t <- t(as.matrix(sapply(TOST.otu.t.con.mean[,1:(ncol(TOST.otu.t.con)-2)], as.numeric)))
TOST.otu.t.muc.t <- t(as.matrix(sapply(TOST.otu.t.muc.mean[,1:(ncol(TOST.otu.t.muc)-2)], as.numeric)))

rtost.t.output.df <- data.frame(matrix(NA, ncol = 3, nrow = nrow(TOST.otu.t.muc)))
colnames(rtost.t.output.df) <- c("Sample1", "Sample2", "P")


for(i in 1:nrow(TOST.otu.t.muc)){
  sample1 <- rownames(TOST.otu.t.muc)[i]
  sample1Split <- strsplit(sample1, "_")
  ID1 <- sample1Split[[1]][[2]]
  
  muc.t <- t(as.matrix(sapply(TOST.otu.muc[i,1:(ncol(TOST.otu.muc)-2)], as.numeric)))
  rtostOutput <- rtost(muc.t, TOST.otu.t.con.t, paired = F, epsilon = 0.25, tr = 0.15)
      
  rtost.t.output.df$Sample1[i] = sample1
  rtost.t.output.df$Sample2[i] = "Torpor Content"
  rtost.t.output.df$P[i] = rtostOutput$p.value
}

rtost.t.output.df$Padj <- p.adjust(rtost.t.output.df$P, "fdr")



#Format OTU table
TOST.otu.i <- data.frame(t(data.frame(otu_table(physeq.iba))))
TOST.otu.i$Sample <- rownames(TOST.otu.i)
TOST.otu.i$Sample_Type <- substr(rownames(TOST.otu.i), start = 2, stop = 2)

# Separate by sample type
TOST.otu.i.con <- TOST.otu.i[which(TOST.otu.i$Sample_Type == "C"),]
TOST.otu.i.muc <- TOST.otu.i[which(TOST.otu.i$Sample_Type == "M"),]

# Calculate OTU means; remove Sample and Sample Type cols I made
TOST.otu.i.con.mean <- aggregate(TOST.otu.i.con[ , 1 : ( ncol(TOST.otu.i.con) - 2) ],
                               list(TOST.otu.i.con$Sample_Type), mean)
TOST.otu.i.con.mean <- TOST.otu.i.con.mean[-1]
TOST.otu.i.muc.mean <- aggregate(TOST.otu.i.muc[ , 1 : ( ncol(TOST.otu.i.muc) - 2) ],
                               list(TOST.otu.i.muc$Sample_Type), mean)
TOST.otu.i.muc.mean <- TOST.otu.i.muc.mean[-1]


# Prepare data
TOST.otu.i.con.i <- t(as.matrix(sapply(TOST.otu.i.con.mean[,1:(ncol(TOST.otu.i.con)-2)], as.numeric)))
TOST.otu.i.muc.i <- t(as.matrix(sapply(TOST.otu.i.muc.mean[,1:(ncol(TOST.otu.i.muc)-2)], as.numeric)))

rtost.i.output.df <- data.frame(matrix(NA, ncol = 3, nrow = nrow(TOST.otu.i.muc)))
colnames(rtost.i.output.df) <- c("Sample1", "Sample2", "P")


for(i in 1:nrow(TOST.otu.i.muc)){
  sample1 <- rownames(TOST.otu.i.muc)[i]
  sample1Split <- strsplit(sample1, "_")
  ID1 <- sample1Split[[1]][[2]]
  
  muc.i <- t(as.matrix(sapply(TOST.otu.muc[i,1:(ncol(TOST.otu.muc)-2)], as.numeric)))
  rtostOutput <- rtost(muc.i, TOST.otu.i.con.i, paired = F, epsilon = 0.25, tr = 0.15)
      
  rtost.i.output.df$Sample1[i] = sample1
  rtost.i.output.df$Sample2[i] = "IBA Content"
  rtost.i.output.df$P[i] = rtostOutput$p.value
}

rtost.i.output.df$Padj <- p.adjust(rtost.i.output.df$P, "fdr")




#Format OTU table
TOST.otu.t <- data.frame(t(data.frame(otu_table(physeq.tor))))
TOST.otu.t$Sample <- rownames(TOST.otu.t)
TOST.otu.t$Sample_Type <- substr(rownames(TOST.otu.t), start = 2, stop = 2)

# Separate by sample type
TOST.otu.t.con <- TOST.otu.t[which(TOST.otu.t$Sample_Type == "C"),]
TOST.otu.t.muc <- TOST.otu.t[which(TOST.otu.t$Sample_Type == "M"),]

# Calculate OTU means; remove Sample and Sample Type cols I made
TOST.otu.t.con.mean <- aggregate(TOST.otu.t.con[ , 1 : ( ncol(TOST.otu.t.con) - 2) ],
                               list(TOST.otu.t.con$Sample_Type), mean)
TOST.otu.t.con.mean <- TOST.otu.t.con.mean[-1]
TOST.otu.t.muc.mean <- aggregate(TOST.otu.t.muc[ , 1 : ( ncol(TOST.otu.t.muc) - 2) ],
                               list(TOST.otu.t.muc$Sample_Type), mean)
TOST.otu.t.muc.mean <- TOST.otu.t.muc.mean[-1]


# Prepare data
TOST.otu.t.con.t <- t(as.matrix(sapply(TOST.otu.t.con.mean[,1:(ncol(TOST.otu.t.con)-2)], as.numeric)))
TOST.otu.t.muc.t <- t(as.matrix(sapply(TOST.otu.t.muc.mean[,1:(ncol(TOST.otu.t.muc)-2)], as.numeric)))

rtost.t.output.df <- data.frame(matrix(NA, ncol = 3, nrow = nrow(TOST.otu.t.muc)))
colnames(rtost.t.output.df) <- c("Sample1", "Sample2", "P")


for(i in 1:nrow(TOST.otu.t.muc)){
  sample1 <- rownames(TOST.otu.t.muc)[i]
  sample1Split <- strsplit(sample1, "_")
  ID1 <- sample1Split[[1]][[2]]
  
  muc.t <- t(as.matrix(sapply(TOST.otu.muc[i,1:(ncol(TOST.otu.muc)-2)], as.numeric)))
  rtostOutput <- rtost(muc.t, TOST.otu.t.con.t, paired = F, epsilon = 0.25, tr = 0.15)
      
  rtost.t.output.df$Sample1[i] = sample1
  rtost.t.output.df$Sample2[i] = "Torpor Content"
  rtost.t.output.df$P[i] = rtostOutput$p.value
}

rtost.t.output.df$Padj <- p.adjust(rtost.t.output.df$P, "fdr")



#Format OTU table
TOST.otu.p <- data.frame(t(data.frame(otu_table(physeq.spr))))
TOST.otu.p$Sample <- rownames(TOST.otu.p)
TOST.otu.p$Sample_Type <- substr(rownames(TOST.otu.p), start = 2, stop = 2)

# Separate by sample type
TOST.otu.p.con <- TOST.otu.p[which(TOST.otu.p$Sample_Type == "C"),]
TOST.otu.p.muc <- TOST.otu.p[which(TOST.otu.p$Sample_Type == "M"),]

# Calculate OTU means; remove Sample and Sample Type cols I made
TOST.otu.p.con.mean <- aggregate(TOST.otu.p.con[ , 1 : ( ncol(TOST.otu.p.con) - 2) ],
                               list(TOST.otu.p.con$Sample_Type), mean)
TOST.otu.p.con.mean <- TOST.otu.p.con.mean[-1]
TOST.otu.p.muc.mean <- aggregate(TOST.otu.p.muc[ , 1 : ( ncol(TOST.otu.p.muc) - 2) ],
                               list(TOST.otu.p.muc$Sample_Type), mean)
TOST.otu.p.muc.mean <- TOST.otu.p.muc.mean[-1]


# Prepare data
TOST.otu.p.con.p <- t(as.matrix(sapply(TOST.otu.p.con.mean[,1:(ncol(TOST.otu.p.con)-2)], as.numeric)))
TOST.otu.p.muc.p <- t(as.matrix(sapply(TOST.otu.p.muc.mean[,1:(ncol(TOST.otu.p.muc)-2)], as.numeric)))

rtost.p.output.df <- data.frame(matrix(NA, ncol = 3, nrow = nrow(TOST.otu.p.muc)))
colnames(rtost.p.output.df) <- c("Sample1", "Sample2", "P")


for(i in 1:nrow(TOST.otu.p.muc)){
  sample1 <- rownames(TOST.otu.p.muc)[i]
  sample1Split <- strsplit(sample1, "_")
  ID1 <- sample1Split[[1]][[2]]
  
  muc.p <- t(as.matrix(sapply(TOST.otu.muc[i,1:(ncol(TOST.otu.muc)-2)], as.numeric)))
  rtostOutput <- rtost(muc.p, TOST.otu.p.con.p, paired = T, epsilon = 0.25, tr = 0.15)
      
  rtost.p.output.df$Sample1[i] = sample1
  rtost.p.output.df$Sample2[i] = "IBA Content"
  rtost.p.output.df$P[i] = rtostOutput$p.value
}

rtost.p.output.df$Padj <- p.adjust(rtost.p.output.df$P, "fdr")

```


### Phylogenetic Diversity and SES MPD
```{r}
### Unweighted - Calculate phylogenetic diversity and MPD ###

# Calculate Faith's phylogenetic diversity
pd.res <- pd(t(data.frame(otu_table(physeq.pair))), phy_tree(physeq.pair), 
             include.root = T)
pd.df <- data.frame(pd.res)

# Calculate MPD (Mean Pairwise Distance)
pd.dist <- cophenetic(phy_tree(physeq.pair))
  # Calculate cophenetic distance
ses.mpd.res <- ses.mpd(t(data.frame(otu_table(physeq.pair))), pd.dist, 
                       null.model = "taxa.labels", abundance.weighted = F, runs = 999)
  # Calculate MPD
  # This'll take a while to run-- be patient
mpd <- data.frame(ses.mpd.res)
  # Pull out MDP results


### Prepare data for plotting ###
mpd$SampleID <- row.names(mpd)
pd.res$SampleID <- row.names(pd.res)
  # Make sure all SampleID's match!

# Pull out first Stat of each test
# PD test = PD
# MPD test = SES (Standardized Effect Size)
pd.stats <- data.frame(pd.res$SampleID, pd.res$PD)
pd.stats$Measure <- rep("PD", nrow(pd.df))
colnames(pd.stats) <- c("Sample", "Stat", "Measure")
mpd.stats <- data.frame(mpd$SampleID, mpd$mpd.obs.z)
mpd.stats$Measure <- rep("MPD SES", nrow(pd.df))
colnames(mpd.stats) <- c("Sample", "Stat", "Measure")



### Prepare PD ###
pd.ready <- merge(pd.stats, meta, by = "Sample")
pd.ready$Group <- ordered(pd.ready$Group, levels = c("Summer_Wild", "Summer_Lab", "Torpor", "IBA", "Spring"))


### Prepare MPD ###
mpd.ready <- merge(mpd.stats, meta, by = "Sample")
mpd.ready$Group <- ordered(mpd.ready$Group, levels = c("Summer_Wild", "Summer_Lab", "Torpor", "IBA", "Spring"))





########## TESTING PD & MPD ##########

# For the paired tests, the tests assume that your samples are in the same order (same order of ID for both content and mucosa)
# Make sure you check ID orders!!!

### Test PD ###
hist(pd.ready$Stat, breaks=10)
qqnorm(pd.ready$Stat)
qqline(pd.ready$Stat)
shapiro.test(pd.ready$Stat)
  # p-value = 9.477e-06
  # Not Normal

wilcox.test(Stat ~ Sample_Type, data = pd.ready, paired = T)
  # p-value = 0.5782



### Test MPD ###
hist(mpd.ready$Stat, breaks=10)
qqnorm(mpd.ready$Stat)
qqline(mpd.ready$Stat)
shapiro.test(mpd.ready$Stat)
  # p-value = 0.06388
  # Normal

t.test(Stat ~ Sample_Type, data = mpd.ready, paired = T)
  # p-value = 0.7998
```

### Alpha Diversity
```{r}
adiv <- data.frame(sample_data(physeq.pair))

########## Compare Con vs. Muc within Group ##########

# Separate by season
adiv.wild <- adiv[which(adiv$Group == "Summer_Wild"),]
adiv.sum <- adiv[which(adiv$Group == "Summer_Lab"),]
adiv.tor <- adiv[which(adiv$Group == "Torpor"),]
adiv.iba <- adiv[which(adiv$Group == "IBA"),]
adiv.spr <- adiv[which(adiv$Group == "Spring"),]


########## Shannon ##########
hist(adiv$shannon, breaks=10)
qqnorm(adiv$shannon)
qqline(adiv$shannon)
shapiro.test(adiv$shannon)
  # p-value = 0.4637
  # Normal

### T-Test ###
t.test(shannon ~ Sample_Type, data = adiv, paired = T)
  # p-value = 0.8903



########## Number of Unique OTUs ##########
otus <- data.frame(otu_table(physeq.pair))
sampNames <- colnames(otus)
uniq.otus <- data.frame(matrix(nrow = nsamples(physeq.pair), ncol = 2))
colnames(uniq.otus) <- c("Sample", "Unique_OTUs")
for(n in 1:nsamples(physeq.pair)) {
  COL <- otus[,n]
  numUniq <- length(which(COL > 0))
  uniq.otus$Sample[n] <- sampNames[n]
  uniq.otus$Unique_OTUs[n] <- numUniq
}
uniq.otus$Sample_Type <- sample_data(physeq.pair)$Sample_Type
rownames(uniq.otus) <- uniq.otus$Sample

hist(uniq.otus$Unique_OTUs, breaks=10)
qqnorm(uniq.otus$Unique_OTUs)
qqline(uniq.otus$Unique_OTUs)
shapiro.test(uniq.otus$Unique_OTUs)
  # p-value = 5.043e-06
  # Not Normal
wilcox.test(Unique_OTUs ~ Sample_Type, data = uniq.otus, paired = T)
  # p-value = 0.9036

```



### Beta Diversity
```{r}
########## Unweighted UniFrac ##########
UF.u <- phyloseq::distance(physeq = physeq.pair, method = "unifrac")
UF.u.pcoa <- ordinate(physeq = physeq.pair, method = "PCoA", distance = "unifrac")
  # Variation explained = 27.7%
plot_ordination(physeq = physeq.pair, ordination = UF.u.pcoa, axes = c(1,2),
                title = "Unweighted UniFrac") +
  geom_point(size = 2, aes(colour = Sample_Type))

### Test
pair.sampdf <- data.frame(sample_data(physeq.pair))
beta.tax <- betadisper(d=UF.u, group=pair.sampdf$Sample_Type)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.236
adonis(UF.u ~ Sample_Type, data = pair.sampdf, permutations = 9999)
  # p-value = 0.9991




########## Weighted UniFrac ##########
UF.w <- phyloseq::distance(physeq = physeq.pair, method = "wunifrac")
UF.w.pcoa <- ordinate(physeq = physeq.pair, method = "PCoA", distance = "wunifrac")
  # Variation explained = 35.7%

plot_ordination(physeq = physeq.pair, ordination = UF.w.pcoa, axes = c(1,2),
                title = "Weighted UniFrac") +
  geom_point(size = 2, aes(colour = Sample_Type))


### PERMANOVA ###
pair.sampdf <- data.frame(sample_data(physeq.pair))
beta.tax <- betadisper(d=UF.w, group=pair.sampdf$Sample_Type)
p <- permutest(beta.tax)
p$tab
  # p-value = 0.088
adonis(UF.w ~ Sample_Type, data = pair.sampdf, permutations = 9999)
  # p-value = 0.9964
```
